{"disqus":{"path":"/posts/2012-04-27-writing-functional-code-in-c-iv-algebraic-datatypes/","commentCount":4,"comments":[{"postId":"4303142987","parentPostId":null,"date":"2012-07-21T11:27:20Z","author":"Cl&#233;ment","avatar":"","message":"<p>Amusing solution! I'd like to expend on the first few lines of your article though:<br>  \"Very roughly, where object orientation uses derivation, functional programming uses algebraic datatypes. \"<br>Expanding on this, you could implement your <code>LivinEntity</code> type like this:<br><code><br>#include<br>using namespace std;<br>class LivingEntity {<br>    public:<br>        string name;<br>        virtual void print() = 0;<br>        LivingEntity(string name) {<br>            this-&gt;name = name;<br>        }<br>        class Person;<br>        class Dog;<br>};<br>class LivingEntity::Person : LivingEntity {<br>    public:<br>        Person(string name) : LivingEntity(name) {}<br>        void print() {<br>            cout &lt;&lt; \"I am a per named \" &lt;&lt; name &lt;&lt; endl;<br>        }<br>};<br>class LivingEntity::Dog : LivingEntity {<br>    public:<br>        Dog(string name) : LivingEntity(name) {}<br>        void print() {<br>            cout &lt;&lt; \"I am a dog named \" &lt;&lt; name &lt;&lt; endl;<br>        }<br>};<br>int main()<br>{<br>    LivingEntity::Dog a_dog = LivingEntity::Dog(\"a dog\");<br>    LivingEntity::Person a_person = LivingEntity::Person(\"a person\");<br>    a_dog.print();<br>    a_person.print();<br>    return 0;<br>}<br></code><br>Also, why do you use <code>else if(true) { __VA_ARGS__}</code> instead of just <code>else { __VA_ARGS__}</code> in your macros?<br>Thanks for the nice article!</p>","replies":[{"postId":"4303143008","parentPostId":"4303142987","date":"2012-07-23T17:25:46Z","author":"lucabol","avatar":"","message":"<p>Hi Clement,<br>Yes, you can simulate algebraic datatypes with inheritance and type testing, albeit more verbosely and less efficiently. The if(true) thing is just a bug. Probably at some point in the coding the condition was a bit more interesting.</p>","replies":[]}]},{"postId":"4303142991","parentPostId":null,"date":"2012-07-21T11:30:47Z","author":"Cl&#233;ment","avatar":"","message":"<p>I've developped this idea on my own blog, <a href=\"http://pit-claudel.fr/clement/blog/using-abstract-classes-to-simulate-tagged-unions-aka-sum-types/\" rel=\"nofollow noopener\" title=\"http://pit-claudel.fr/clement/blog/using-abstract-classes-to-simulate-tagged-unions-aka-sum-types/\">http://pit-claudel.fr/clement/blog/using-abstract-classes-to-simulate-tagged-unions-aka-sum-types/</a></p>","replies":[]},{"postId":"4303142994","parentPostId":null,"date":"2017-02-02T03:30:51Z","author":"Christoph Senjak","avatar":"","message":"<p>Does this also work with recursive datatypes?</p>","replies":[]}]}}