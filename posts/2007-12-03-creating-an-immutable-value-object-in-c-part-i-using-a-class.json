{"disqus":{"path":"/posts/2007-12-03-creating-an-immutable-value-object-in-c-part-i-using-a-class/","commentCount":18,"comments":[{"postId":"4303143944","parentPostId":null,"date":"2007-12-06T01:13:48Z","author":"AlexVB","avatar":"","message":"<p>I am actually a little bit confused but I really belive that classes are reference objects in .NET; so naming \"Creating immutable &gt;&gt;value objects&lt;&lt;....\" looks a bit freak. Does not it?<br>So in this case the only thing a developer must do is to properly implement base functionality, i mean base functions available in object class and just protect all the internal data the real object contains.... So the question is what do you really want to write about, new stuff about implementation of base object's functionality that is quite well covered by Rihter and other authors or something new. sorry if i am too rude :) i just really cant get the clue of the article</p>","replies":[]},{"postId":"4303143940","parentPostId":null,"date":"2007-12-06T12:34:12Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts: Part I - Using a class In the previous post I showed how to trivially implement a value</p>","replies":[]},{"postId":"4303143946","parentPostId":null,"date":"2007-12-06T12:51:18Z","author":"Noticias externas","avatar":"","message":"<p>Other posts: Part I - Using a class In the previous post I showed how to trivially implement a value</p>","replies":[]},{"postId":"4303143952","parentPostId":null,"date":"2007-12-07T15:21:29Z","author":"Kirill Osenkov","avatar":"","message":"<p>One could probably replace<br>            if ((object)v2 == null)<br>                return true;<br>            else<br>                return false;<br>with<br>            return (object)v2 == null;<br>and<br>        if (span.Intersect(other) == other)<br>            return true;<br>        return false;<br>with<br>        return span.Intersect(other) == other;<br>Just my 2 cents ;-)</p>","replies":[]},{"postId":"4303143943","parentPostId":null,"date":"2007-12-17T13:07:35Z","author":"Luca","avatar":"","message":"<p>Yep, one certainly could :)<br>I have always tended to state the obvious in my code. Once upon a time I thought it to be a bad thing. Now I think it is good.<br>Maybe I'm just getting old ...</p>","replies":[]},{"postId":"4303143945","parentPostId":null,"date":"2007-12-18T12:40:51Z","author":"Greg","avatar":"","message":"<p>Checklist for locking down an object:<br>1. Object must be constructed with constructor arguments that initialize all fields. Default constructor is hidden (private).  A class factory with a hidden constructor works as well.<br>2. Assignment operator does a deep copy of the object.  Member variables cannot be referred too by more than one object<br>3. Equality tests both == and != must test member variables and not the object pointer/reference<br>4. (optional) You cannot get a modifiable reference to the object (C++ only) or a pointer to the object<br>5. Compound properties, consisting of 2 or more member variables, must be modified all at one time (i.e., may not be modified individually).<br>6. (Allied Concept) Any data stored by the application must be accessible using stored procedures.  Do not access the tables directly.<br>7. (Allied Concept) Allow multiple copies of the object but have them refer to the same static data (i.e. a single copy of the data usually encapsulated in a static object).<br>This is standard practice in C++ from 1990 and even earlier than that in ADA and Smalltalk.<br>It is a good practice, but should be used with restraint because the modularity and/or productivity gains are small for each object using this pattern.  Taking modularity higher, such as the business function or major functional module level, usually is more effective.<br>Generally, over-emphasis on micro-modularity leads to longer development times and systems significantly harder to maintain.</p>","replies":[]},{"postId":"4303143948","parentPostId":null,"date":"2007-12-24T12:38:02Z","author":"fernando","avatar":"","message":"<p>Immutable values are created as structs in c#, if you set a struct variable to another variable of the same type as in:<br>struct1 var1 = new struct1(field1, field2);<br>struct1 var2 = var1;<br>var2 ends up being a deep copy of var1 stored on a seperate memory location. That's what an immutable type is, if you do that with your class, var2 will be a pointer to the same memory location where var1's value is stored, therefore it is NOT an immutable type.<br>Incidentally, except for #4, #5 and #6 on Greg's checklist all other checklist items are true characteristics of a .NET structure. 1) Default constructor is hidden and ctor initializes all fields, 2) assignment operator does a deep copy of the object (as I mentioned above), 3) equality tests test the value, not the pointer, and 7) it allows multiple copies of the object but all of them refer to the same data.</p>","replies":[]},{"postId":"4303143959","parentPostId":null,"date":"2007-12-24T17:39:24Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better In Part II I talked about the asymmetry</p>","replies":[]},{"postId":"4303143958","parentPostId":null,"date":"2007-12-24T18:01:24Z","author":"Noticias externas","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better In Part II I talked about the asymmetry</p>","replies":[]},{"postId":"4303143961","parentPostId":null,"date":"2007-12-28T18:45:33Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better Part III - Using a struct In the</p>","replies":[]},{"postId":"4303143962","parentPostId":null,"date":"2007-12-28T19:06:18Z","author":"Noticias externas","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better Part III - Using a struct In the</p>","replies":[]},{"postId":"4303143963","parentPostId":null,"date":"2008-01-11T13:36:11Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better Part III - Using a struct Part</p>","replies":[]},{"postId":"4303143965","parentPostId":null,"date":"2008-01-11T13:52:04Z","author":"Noticias externas","avatar":"","message":"<p>Other posts: Part I - Using a class Part II - Making the class better Part III - Using a struct Part</p>","replies":[]},{"postId":"4303143966","parentPostId":null,"date":"2008-01-16T18:36:52Z","author":"Tales from the Evil Empire","avatar":"","message":"<p>For some reason, there's been a lot of buzz lately around immutability in C#. If you're interested in</p>","replies":[]},{"postId":"4303143970","parentPostId":null,"date":"2008-04-03T13:12:58Z","author":"brute forced brilliance","avatar":"","message":"<p>It's Time for a Change -- We need Immutable Types</p>","replies":[]},{"postId":"4303143974","parentPostId":null,"date":"2008-04-21T13:35:43Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Previous posts: Part I - Background Part II - Tuples Now that we know what Tuples are, we can start talking</p>","replies":[]},{"postId":"4303143973","parentPostId":null,"date":"2008-06-03T15:37:37Z","author":"adamjcooper.com/blog","avatar":"","message":"<p>The Quest for Quick-and-Easy Class-Based Immutable Value Objects in C# - Part 1: Introduction</p>","replies":[]},{"postId":"4303143976","parentPostId":null,"date":"2008-06-03T16:57:17Z","author":"adamjcooper.com/blog","avatar":"","message":"<p>The Quest for Quick-and-Easy Immutable Value Objects in C#</p>","replies":[]}]}}