{"disqus":{"path":"/posts/2008-04-08-a-c-library-to-write-functional-code-part-ii-tuples/","commentCount":16,"comments":[{"postId":"4303143704","parentPostId":null,"date":"2008-04-08T22:00:51Z","author":"AC# library to write functiona","avatar":"","message":"<p>PingBack from <a href=\"http://airconditioner.crutoo.com/2008/04/08/ac-library-to-write-functional-code-part-ii-tuples/\" rel=\"nofollow noopener\" title=\"http://airconditioner.crutoo.com/2008/04/08/ac-library-to-write-functional-code-part-ii-tuples/\">http://airconditioner.crutoo.com/2008/04/08/ac-library-to-write-functional-code-part-ii-tuples/</a></p>","replies":[]},{"postId":"4303143718","parentPostId":null,"date":"2008-04-09T12:57:29Z","author":"Jacob","avatar":"","message":"<p>What about:<br>internal static bool DSEquals&lt;T&gt;(T left, T right) {<br>    if (left == null &amp;&amp; right == null)<br>        return true;<br>    if (left == null &amp;&amp; right != null)<br>        return false;<br>    var len = left as IEnumerable;<br>    var ren = right as IEnumerable;<br>    if (len == null &amp;&amp; ren == null)<br>        return left.Equals(right);<br>    if (len != null &amp;&amp; ren != null)<br>        return SequenceEqual(len, ren);<br>    return false;<br>}</p>","replies":[]},{"postId":"4303143705","parentPostId":null,"date":"2008-04-16T09:47:44Z","author":"Adam Cooper","avatar":"","message":"<p>Luca,<br>Thanks so much for sharing this, both your posts and the source code.<br>I really like your idea of bringing some (more) of F#'s goodness to C#. I spent some time investigating if F# was the right tool for some of our company projects and, while I think F# is fantastic, our domain is one of storing and retrieving lots of hierarchical data, a domain which is ideal for an object-oriented language like C#. So C# is the clear choice for us (in the vast majority of cases). However, there are quite a few aspects of functional programming I'm really beginning to admire.<br>I've never been happy with the OO paradigm of many-inputs-one-output, and I find your Tuples solution exciting. Can you comment on how your Tuples implementation differs from anonymous types in C#?<br>Thanks and keep up the good work,<br>Adam Cooper</p>","replies":[]},{"postId":"4303143708","parentPostId":null,"date":"2008-04-16T12:26:06Z","author":"lucabol","avatar":"","message":"<p>Thanks for the kind words.<br>There are two differences:<br>1. Anonymous types allow you to give a name to each property, while tuple don't.<br>2. You cannot return anonymous types from methods or passing them as parameters. So their used is limited to the body of a method.<br>Overall anonymous types are a mix of tuples and records. I'll talk about records in an upcoming post.</p>","replies":[]},{"postId":"4303143709","parentPostId":null,"date":"2008-04-21T13:35:42Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Previous posts: Part I - Background Part II - Tuples Now that we know what Tuples are, we can start talking</p>","replies":[]},{"postId":"4303143729","parentPostId":null,"date":"2008-04-23T16:58:14Z","author":"Charlie Calvert's Community Bl","avatar":"","message":"<p>Welcome to the forty-third issue of Community Convergence. The last few weeks have been consumed by the</p>","replies":[]},{"postId":"4303143730","parentPostId":null,"date":"2008-04-24T04:12:14Z","author":"Configurator","avatar":"","message":"<p>I'm wondering: Doesn't CheckNull cause an infinite loop?<br>Usually when checking null, I would use ReferenceEquals(t, null) because == would call the type's operator ==, which checks for null causing an infinite loop.<br>If CheckNull accepted an object and wasn't generic, if would use object's ==, which works for null. But since it's generic it should use the == that you supplied.<br>Am I missing something here?</p>","replies":[]},{"postId":"4303143739","parentPostId":null,"date":"2008-04-24T05:04:04Z","author":"Eamon Nerbonne","avatar":"","message":"<p>I've also needed to build these things, and have also run into some of the same issues you seem to have here - like the surprising unhandiness of structs (and even more surprising slowness).<br>Incidentally, your hash-code is no good.  You don't want to use a symmetric combination of two hash codes, since that means that F.Tuple(true,false) is equal to F.Tuple(false, true) in terms of hashcode.  A non-symmetric combination is probably best; but the instantly obvious subtraction is definitely not a good idea, since that means that all tuples of two elements with identical members have a hash-code of 0.<br>I choose to scale the hashcode with a prime number.  Trial and error on my test-set (consisting of lower-case strings which may not be representative for others) found that 137 is fine; so that's what I use, but I haven't researched the issue.<br>Further, if your tuples will be used extensively in things like lookup tables, then hash-code calculation becomes relevant:  you might want to store the hashcode once and reuse it (which can also help speed up equality comparisons when these are performed outside of a hash table).</p>","replies":[]},{"postId":"4303143740","parentPostId":null,"date":"2008-04-24T13:11:46Z","author":"lucabol","avatar":"","message":"<p>It doesn't go into an infinite loop because it is generic. We cannot call the overload == because at that point in the code we don't know what it is. So we box it and 'compare the pointer' insted. The commented IL for the function should clarify:<br>.method public hidebysig static void CheckNull&lt;T&gt;(!!T t) cil managed<br>{<br>    .maxstack 2<br>    .locals init (<br>        [0] bool CS$4$0000)<br>    L_0000: nop<br>    L_0001: ldarg.0<br>    L_0002: box !!T // We box it<br>    L_0007: ldnull<br>    L_0008: ceq // We compare it<br>    L_000a: ldc.i4.0<br>    L_000b: ceq<br>    L_000d: stloc.0<br>    L_000e: ldloc.0<br>    L_000f: brtrue.s L_0017<br>    L_0011: newobj instance void [mscorlib]System.ArgumentNullException::.ctor()<br>    L_0016: throw<br>    L_0017: ret<br>}</p>","replies":[]},{"postId":"4303143753","parentPostId":null,"date":"2008-04-24T13:12:23Z","author":"lucabol","avatar":"","message":"<p>Eamon: I know my hash is bad. I was too lazy to produce a better one :)</p>","replies":[]},{"postId":"4303143766","parentPostId":null,"date":"2008-04-28T00:42:14Z","author":"David Nelson","avatar":"","message":"<p>The problem with your \"this should never be null\" logic is that it prevents the user from ever writing code like this:<br>Tuple&lt;int, int&gt; MyMethod()<br>{<br>   Tuple&lt;int, int&gt; result = null;<br>   // Some code which may or may not set result<br>   if(result == null)<br>   {<br>      // Some other code which always sets the result<br>   }<br>   return result;<br>}<br>This is a reasonably common pattern. Your code is checking for null in the wrong place. It is not unreasonable that any Tuple reference might  sometimes be null. Tuples should only be checked for null where it is sure that they should never be null.</p>","replies":[]},{"postId":"4303143767","parentPostId":null,"date":"2008-04-28T13:27:17Z","author":"lucabol","avatar":"","message":"<p>Hi David,<br>I used this code to learn functional programming. In that style variables are immutable, which makes the code you present invalid. So, in my scenario, my decision makes sense.<br>In a more generic sense, you have to trade off the annoyance of not being able to write the code you present and the annoyance of not catching bugs because you return false instead of throwing. Reasonable people can come up in different places in that debate.</p>","replies":[]},{"postId":"4303143777","parentPostId":null,"date":"2008-05-03T21:56:50Z","author":"John Mertus","avatar":"","message":"<p>Why not just return a dictionary from the function.  The key of the dictionary are the names of the elements of the class, the value objects.  For example<br>  var Person = GetPerson(&lt;some id&gt;);<br>  int age = Person[\"age\"]).ToInt32()<br>  string name = Person[\"FirstName\"].ToString();<br>(Here .ToInt32 is the damn extension C# should have for objects, why the hell doesn't it)<br>Of course  <br>  The big problem is the data binding becomes a var in the java sense; that it is like a late binding and fails at runtime not compile time.   But it gives a better syntax and is more readable than tuples.</p>","replies":[]},{"postId":"4303143774","parentPostId":null,"date":"2008-05-04T18:47:21Z","author":"David Nelson","avatar":"","message":"<p>@John<br>\"Here .ToInt32 is the damn extension C# should have for objects, why the hell doesn't it\"<br>Because the vast majority of types cannot be reasonably represented by an Int32. Presumably if such a ToInt32 method existed, these types would all have to throw an exception. Why would you want to add a parsing method to every single object which will fail most of the time?</p>","replies":[]},{"postId":"4303143780","parentPostId":null,"date":"2008-06-03T16:59:59Z","author":"adamjcooper.com/blog","avatar":"","message":"<p>The Quest for Quick-and-Easy Immutable Value Objects in C#</p>","replies":[]},{"postId":"4303143787","parentPostId":null,"date":"2008-07-15T05:46:24Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts in the series: Part I - Background Part II - Tuples Part III - Records Part IV - Type Unions</p>","replies":[]}]}}