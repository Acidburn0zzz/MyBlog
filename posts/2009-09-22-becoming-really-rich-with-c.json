{"disqus":{"path":"/posts/2009-09-22-becoming-really-rich-with-c/","commentCount":13,"comments":[{"postId":"4303143170","parentPostId":null,"date":"2009-09-23T08:36:49Z","author":"Barry Kelly","avatar":"","message":"<p>Indeed. This is called momentum investing, and is probably at least partially responsible for the bubbles we've seen over the past few decades.<br>You can read more about it here - traders at Morgan Stanley described folks who used this approach as \"fast money scum\":<br><a href=\"http://marketprognosticator.blogspot.com/2009/07/real-vampire-squid-on-face-of-humanity.html\" rel=\"nofollow noopener\" title=\"http://marketprognosticator.blogspot.com/2009/07/real-vampire-squid-on-face-of-humanity.html\">http://marketprognosticator.blogspot.com/2009/07/real-vampire-squid-on-face-of-humanity.html</a></p>","replies":[]},{"postId":"4303143163","parentPostId":null,"date":"2009-09-23T11:28:40Z","author":"lucabol","avatar":"","message":"<p>I'm afraid there is plenty of research on this factor (as there is on value). For a summary of it read here: <a href=\"http://www.cxoadvisory.com/blog/internal/blog-momentum-investing/Default.asp\" rel=\"nofollow noopener\" title=\"http://www.cxoadvisory.com/blog/internal/blog-momentum-investing/Default.asp\">http://www.cxoadvisory.com/blog/internal/blog-momentum-investing/Default.asp</a></p>","replies":[]},{"postId":"4303143172","parentPostId":null,"date":"2009-09-26T21:37:15Z","author":"ETFpickr","avatar":"","message":"<p>FYI...<br>You can pull up a very similar set of data points for every ETF in the U.S. Market on my website <a href=\"http://ETFtable.com\" rel=\"nofollow noopener\" title=\"http://ETFtable.com\">http://ETFtable.com</a> (also built in .NET)<br>You then sort by a number of different measures of performance and trend, and also filter the full list of ETFs to just a subset of ETFs that you track. Try it out and let me know what you think.</p>","replies":[]},{"postId":"4303143164","parentPostId":null,"date":"2009-09-26T22:09:49Z","author":"lucabol","avatar":"","message":"<p>Lovely, I like the simplicity.<br>But I still like to be able to customize things even more. Then, consider my beautiful user interface :-)</p>","replies":[]},{"postId":"4303143160","parentPostId":null,"date":"2009-09-27T09:20:55Z","author":"mic","avatar":"","message":"<p>take everything out and remember this statement \"investment is not about timing it is about time\"</p>","replies":[]},{"postId":"4303143186","parentPostId":null,"date":"2009-09-27T11:07:22Z","author":"lucabol","avatar":"","message":"<p>Or was it the other way around? :-) :-)</p>","replies":[]},{"postId":"4303143192","parentPostId":null,"date":"2009-09-27T14:31:55Z","author":"jon","avatar":"","message":"<p>Liked the new C# tricks. Thanks for sharing!</p>","replies":[]},{"postId":"4303143195","parentPostId":null,"date":"2009-09-28T06:39:23Z","author":"geo","avatar":"","message":"<p>Pretty nice, but I would have gone with a scripting language for this job. I think the development speed would have been greater.</p>","replies":[]},{"postId":"4303143197","parentPostId":null,"date":"2009-10-17T20:23:16Z","author":"geoff","avatar":"","message":"<p>@ geo re: Pretty nice, but I would have gone with a scripting language for this job. I think the development speed would have been greater.<br>Can someone please explain why a scripting language would make development speed better, and any other benefits.  I've heard statements like this and am curious as to why you would choose it over something like the author used, especially when he wrote it in a console without much overhead.</p>","replies":[]},{"postId":"4303143205","parentPostId":null,"date":"2009-10-19T14:43:46Z","author":"Tim","avatar":"","message":"<p>Thanks for this great example on the power of C# .NET4. It has been a real eye opener for me. Amazing stuff!<br>It all makes sense except the Parallel For. I can see why it ends up working, but it seems less than optimal and or needlessly complex. Maybe I an missing something?<br>Parallel.For(0, len, i =&gt; {<br>    var t = tickers[i];<br>    var url = CreateUrl(t.Item1, start, end);<br>    using (var webClient = new WebClient()) {<br>        webClient.DownloadStringCompleted +=<br>                          new DownloadStringCompletedEventHandler(downloadStringCompleted);<br>        webClient.DownloadStringAsync(new Uri(url), Tuple.Create(t, cevent, summaries, i));<br>    }<br>}<br>);<br>Observation 1: Surely by calling DownloadStringAsync you are handling the work of actually doing the http get to a thread in a thread pool. Doesn't this make the Parallel For redundant? The only thing that it is potentially parallelizing is the creation of the URL string which is pretty minor.<br>Observation 2: Surely you only need to create one WebClient object if you are going to use DownloadStringAsync as it returns immediately handing off the job to a thread in thread pool.<br>Observation 3: With a single WebClient you would only need a single DownloadStringCompletedEventHandler. Not a big overhead but still.<br>Observation 4: The using clause will call the dispose method on each WebClient. But presumably this will block until webClient.isBusy() is false. So these (potential) threads created by the  Parallel For will create a url, hand off the work of actually getting the url to a thread pool (as a result of calling DownloadStringAsync) and then block on the dispose method until the get method. Seems a bit of an overkill.<br>I have not actually run you code so I am not able to try my theories out! But surely this is all you need?<br>&lt;pre&gt;<br>webClient.DownloadStringCompleted +=<br>                          new DownloadStringCompletedEventHandler(downloadStringCompleted);<br>using (var webClient = new WebClient()) {<br>  for(i = 0; i &lt; len, ++i) {<br>    var t = tickers[i];<br>    var url = CreateUrl(t.Item1, start, end);<br>    webClient.DownloadStringAsync(new Uri(url),<br>      Tuple.Create(t, cevent, summaries, i));<br>  }<br>}<br>&lt;/pre&gt;<br>Apoligies if the code formatting is shot!<br>Anyway thanks for a superb blog and apologies if I have misunderstood how WebClient.DownloadStringAsync works.</p>","replies":[]},{"postId":"4303143202","parentPostId":null,"date":"2009-10-19T16:37:00Z","author":"lucabol","avatar":"","message":"<p>Hi Tim,<br>You are right. Parallel.For is unnecessary and I could have used just one WebClient.<br>Thanks for pointing this out.</p>","replies":[]},{"postId":"4303143219","parentPostId":null,"date":"2009-10-20T09:37:59Z","author":"lucabol","avatar":"","message":"<p>I shouldn't speak without trying out the code. Now I did and you are half right and half wrong. Parallel.For is somehow unnecessary as you are not doing much work in there, but multiple WebClients are needed.<br>Something along the line of your code gives:<br>Unhandled Exception: System.NotSupportedException: WebClient does not support concurrent I/O operations.<br>   at System.Net.WebClient.ClearWebClientState()<br>   at System.Net.WebClient.DownloadStringAsync(Uri address, Object userToken)<br>   at ETFAnalyzer.Program.Main(String[] args) in C:ProjectsETFAnalyzerETFAnalyzerProgram.cs:line 238<br>I will change the code to use a simple for loop.</p>","replies":[]},{"postId":"4303143221","parentPostId":null,"date":"2009-10-20T12:24:43Z","author":"Tim","avatar":"","message":"<p>I found an explication of why the Parallel For may be useful with WebClient.DownloadStringAsync here: <a href=\"http://www.informit.com/blogs/blog.aspx?uk=Is-this-really-asynchronous\" rel=\"nofollow noopener\" title=\"http://www.informit.com/blogs/blog.aspx?uk=Is-this-really-asynchronous\">http://www.informit.com/blogs/blog.aspx?uk=Is-this-really-asynchronous</a>. Basically, DownloadStringAsync is not entirely asynchronous. It does the DNS lookup *on*the*calling*thread* first. The comment at the end of the refereced url, explains why it might be still worth using a new thread to call each DownloadStringAsync even though that would appear to double the number of threads required. (There are separate IO and processing threads apparently)</p>","replies":[]}]}}