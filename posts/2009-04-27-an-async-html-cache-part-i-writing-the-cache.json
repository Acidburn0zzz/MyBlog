{"disqus":{"path":"/posts/2009-04-27-an-async-html-cache-part-i-writing-the-cache/","commentCount":6,"comments":[{"postId":"4303143303","parentPostId":null,"date":"2009-04-27T20:27:49Z","author":"An Async Html cache ??? part I","avatar":"","message":"<p>PingBack from <a href=\"http://asp-net-hosting.simplynetdev.com/an-async-html-cache-%e2%80%93-part-i/\" rel=\"nofollow noopener\" title=\"http://asp-net-hosting.simplynetdev.com/an-async-html-cache-%e2%80%93-part-i/\">http://asp-net-hosting.simplynetdev.com/an-async-html-cache-%e2%80%93-part-i/</a></p>","replies":[]},{"postId":"4303143306","parentPostId":null,"date":"2009-04-29T13:20:09Z","author":"Greg","avatar":"","message":"<p>It would be much easier to use a normal thread safe collection class.<br>Each element would have:<br>  key<br>  url (string)<br>  status (loaded, failed, waiting to load, partially loaded)<br>  last status change (date/time)<br>  html_loaded (string)<br>  last_referenced (date/time)<br>  can_timeout_and_be_deleted(boolean)<br>Class methods<br>   Get HTML from URL(boolean lookup_only = false, int max_block_seconds = 0 /* -1 block forever, 0 - don't block, otherwise block for X seconds*/)<br>   Get HTML from KEY(boolean lookup_only = false)<br>   Delete_entry(URL)<br>   Delete_entry(KEY)<br>A thread or threads internal to the class would load the html asychronously and be invoked via a clock timer with ticks a few seconds apart.<br>Attaching a callback for each request is much harder to implement.  It is upto the method requesting the URL to decide whether or not it blocks, needs an asychronous callback/interrupt or polls for data.  <br>The idea is that for nearly all cases, no new threads should be created and no new callbacks should be hooked up.  This keeps your code easier to understand and debug.  Common faults and scenarios are handled easily:<br>  - requesting thread terminates<br>  - asynchronous load times out<br>  - error loading html<br>  - html hasn't been used for 5 minutes and can be removed (a tunable cache parameter)<br>  - memory limit of cache reached and unreferenced html strings can be removed (a tunable cache parameter)<br>  - duplicate request for a URL/KEY from more than one thread<br>  - html can be loaded from multiple sources (web, file, network share, ftp, database, etc.).<br>  - html load failed as html string exceeds the size limit on loaded string (e.g., a tunable cache parameter)<br>  - The common problem with attempting a callback for a method that is terminated is avoided.  That's a problem when the callback requires the cache to build a complex packet of data to pass in the callback.<br>This is quite similar to basic page handling algorithm in a virtual memory system (circa 1980).  It's how one handled this in systems lacking real threading or with non-reentrant GUI message handling (VB6 GUI/MFC GUI posting a message to the current winform indiciating asynchronous request completed).</p>","replies":[]},{"postId":"4303143305","parentPostId":null,"date":"2009-04-29T13:39:11Z","author":"lucabol","avatar":"","message":"<p>Thanks Greg, these are good comments.<br>We have a different design goal though. Both solutions are valid. I want the method requesting the URL to have the flexibility of deciding what to do (aka have a callback). I do want the exposed API to be async.<br>The rest of your comments talk to the difference between writing production code and a conceptual example. I'm doing the latter here.</p>","replies":[]},{"postId":"4303143299","parentPostId":null,"date":"2009-04-29T15:11:51Z","author":"Greg","avatar":"","message":"<p>The idea of wrapping the asychronous cache handler in a class is to reduce or eliminate the need for callers to bbe asychronous.  This makes coding the caller's class much easier.<br>The other aspect is that the amount of work done in an asychronous call back should be minimal since you don't know when it will be executed.  For example, you get a callback call with the HTML you need whilst you are destroying the caller's object.  This is more important when dealing with large amounts of data in each cach entry (e.g., large xml strings) since processing each cache entry may take considerable time.</p>","replies":[]},{"postId":"4303143313","parentPostId":null,"date":"2009-04-29T15:15:28Z","author":"The Visual Basic Team","avatar":"","message":"<p>You may know Luca Bolognese from his well-known work on C# LINQ. Luca is now the Group Program Manager</p>","replies":[]},{"postId":"4303143315","parentPostId":null,"date":"2009-05-08T11:53:22Z","author":"Luca Bolognese's WebLog","avatar":"","message":"<p>Other posts: Part I – Writing the cache Let's try out our little cache. First I want to write a synchronous</p>","replies":[]}]}}