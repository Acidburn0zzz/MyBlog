{"disqus":{"path":"/posts/2007-02-01-apparently-simple-code/","commentCount":5,"comments":[{"postId":"4303143534","parentPostId":null,"date":"2007-02-01T17:24:22Z","author":"barrkel","avatar":"","message":"<p>I don't get it - the code is straightforward recursion, there's nothing complex about it at all. If you've competed in any programming competitions, these kinds of problems are entry-level stuff.<br>The number of ways is 1 if there's no sum left, otherwise it's the number of ways by using all the remaining coins (i.e. skipping this denomination) plus the number of ways by using the coin (i.e. subtracting its value from the amount). It's immediately obvious.</p>","replies":[]},{"postId":"4303143535","parentPostId":null,"date":"2007-02-01T20:56:09Z","author":"lucabol","avatar":"","message":"<p>Well ... to me it is not 'immediately obvious'. I had to sketch it on my whiteboard to visualize it. I guess I'm a much worse programmer than you are.<br>Anyhow, I would have never thought of this algo if someone gave me the text of the problem. I would have come up with something way more convoluted.<br>But again, that's just me ...</p>","replies":[]},{"postId":"4303143544","parentPostId":null,"date":"2007-02-19T13:08:37Z","author":"Charlie Calvert's Community Bl","avatar":"","message":"<p>Welcome to the twenty-first Community Convergence. I'm Charlie Calvert, the C# Community PM, and this</p>","replies":[]},{"postId":"4303143545","parentPostId":null,"date":"2007-02-26T17:49:49Z","author":"choatea","avatar":"","message":"<p>This doesn't work. (At least past 9)  It counts giving (one 5 and five 1's) and (five 1's and one 5) and similar reversals as being distinct.  It's still pretty cool though.  I implemented this to run on .NET 1.1 to check it out.  When it gave these results, I thought it was strange, so I downloaded and ran it on the LINQ May CTP that you originally tested it on, and they give the same result.  I guess if you consider the order in which you give the types of coins, it works.  Small gripe I know...</p>","replies":[]},{"postId":"4303143552","parentPostId":null,"date":"2007-02-27T17:54:32Z","author":"lucabol","avatar":"","message":"<p>When I try to get 10 with [1,5] or [5,1] it gives me 3 as a result:(111111111)(111115)(55). It is not double counting the reversal. When I try to get 15 with [1,5] it gives me 4, which is correct again. Am I misunderstanding you?<br>BTW: if you try [1,5,5] you get 10. It considers the two 5s as different coins. If you don't want this behavior you can simply rename ChangeComb as ChangeCompTemp and add:<br>static int ChangeComb(int amount, IEnumerable&lt;int&gt; coins)<br>{<br>     return ChangeCompTemp(amount, coins.Distinct());<br>}</p>","replies":[]}]}}